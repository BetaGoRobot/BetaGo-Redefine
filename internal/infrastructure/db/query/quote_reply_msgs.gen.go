// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"github.com/BetaGoRobot/BetaGo-Redefine/internal/infrastructure/db/model"
)

func newQuoteReplyMsg(db *gorm.DB, opts ...gen.DOOption) quoteReplyMsg {
	_quoteReplyMsg := quoteReplyMsg{}

	_quoteReplyMsg.quoteReplyMsgDo.IWithDO = gen.WithDOFunc[IQuoteReplyMsgDo](_quoteReplyMsg.quoteReplyMsgDo.withDO)

	_quoteReplyMsg.quoteReplyMsgDo.UseDB(db, opts...)
	_quoteReplyMsg.quoteReplyMsgDo.UseModel(&model.QuoteReplyMsg{})

	tableName := _quoteReplyMsg.quoteReplyMsgDo.TableName()
	_quoteReplyMsg.ALL = field.NewAsterisk(tableName)
	_quoteReplyMsg.MatchType = field.NewString(tableName, "match_type")
	_quoteReplyMsg.Keyword = field.NewString(tableName, "keyword")
	_quoteReplyMsg.Reply = field.NewString(tableName, "reply")
	_quoteReplyMsg.ReplyType = field.NewString(tableName, "reply_type")

	_quoteReplyMsg.fillFieldMap()

	return _quoteReplyMsg
}

type quoteReplyMsg struct {
	quoteReplyMsgDo quoteReplyMsgDo

	ALL       field.Asterisk
	MatchType field.String
	Keyword   field.String
	Reply     field.String
	ReplyType field.String

	fieldMap map[string]field.Expr
}

func (q quoteReplyMsg) Table(newTableName string) *quoteReplyMsg {
	q.quoteReplyMsgDo.UseTable(newTableName)
	return q.updateTableName(newTableName)
}

func (q quoteReplyMsg) As(alias string) *quoteReplyMsg {
	q.quoteReplyMsgDo.DO = *(q.quoteReplyMsgDo.As(alias).(*gen.DO))
	return q.updateTableName(alias)
}

func (q *quoteReplyMsg) updateTableName(table string) *quoteReplyMsg {
	q.ALL = field.NewAsterisk(table)
	q.MatchType = field.NewString(table, "match_type")
	q.Keyword = field.NewString(table, "keyword")
	q.Reply = field.NewString(table, "reply")
	q.ReplyType = field.NewString(table, "reply_type")

	q.fillFieldMap()

	return q
}

func (q *quoteReplyMsg) WithContext(ctx context.Context) IQuoteReplyMsgDo {
	return q.quoteReplyMsgDo.WithContext(ctx)
}

func (q quoteReplyMsg) TableName() string { return q.quoteReplyMsgDo.TableName() }

func (q quoteReplyMsg) Alias() string { return q.quoteReplyMsgDo.Alias() }

func (q quoteReplyMsg) Columns(cols ...field.Expr) gen.Columns {
	return q.quoteReplyMsgDo.Columns(cols...)
}

func (q *quoteReplyMsg) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := q.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (q *quoteReplyMsg) fillFieldMap() {
	q.fieldMap = make(map[string]field.Expr, 4)
	q.fieldMap["match_type"] = q.MatchType
	q.fieldMap["keyword"] = q.Keyword
	q.fieldMap["reply"] = q.Reply
	q.fieldMap["reply_type"] = q.ReplyType
}

func (q quoteReplyMsg) clone(db *gorm.DB) quoteReplyMsg {
	q.quoteReplyMsgDo.ReplaceConnPool(db.Statement.ConnPool)
	return q
}

func (q quoteReplyMsg) replaceDB(db *gorm.DB) quoteReplyMsg {
	q.quoteReplyMsgDo.ReplaceDB(db)
	return q
}

type quoteReplyMsgDo struct {
	gen.GenericsDo[IQuoteReplyMsgDo, *model.QuoteReplyMsg]
}
type IQuoteReplyMsgDo interface {
	gen.IGenericsDo[IQuoteReplyMsgDo, *model.QuoteReplyMsg]
}

func (q *quoteReplyMsgDo) withDO(do gen.Dao) IQuoteReplyMsgDo {
	_r := &quoteReplyMsgDo{}
	_r.DO = *do.(*gen.DO)
	_r.IWithDO = gen.WithDOFunc[IQuoteReplyMsgDo](q.withDO)
	return _r
}

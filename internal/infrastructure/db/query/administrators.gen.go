// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"github.com/BetaGoRobot/BetaGo-Redefine/internal/infrastructure/db/model"
)

func newAdministrator(db *gorm.DB, opts ...gen.DOOption) administrator {
	_administrator := administrator{}

	_administrator.administratorDo.IWithDO = gen.WithDOFunc[IAdministratorDo](_administrator.administratorDo.withDO)

	_administrator.administratorDo.UseDB(db, opts...)
	_administrator.administratorDo.UseModel(&model.Administrator{})

	tableName := _administrator.administratorDo.TableName()
	_administrator.ALL = field.NewAsterisk(tableName)
	_administrator.ID = field.NewInt64(tableName, "id")
	_administrator.CreatedAt = field.NewTime(tableName, "created_at")
	_administrator.UpdatedAt = field.NewTime(tableName, "updated_at")
	_administrator.DeletedAt = field.NewField(tableName, "deleted_at")
	_administrator.UserID = field.NewInt64(tableName, "user_id")
	_administrator.UserName = field.NewString(tableName, "user_name")
	_administrator.Level = field.NewInt64(tableName, "level")

	_administrator.fillFieldMap()

	return _administrator
}

type administrator struct {
	administratorDo administratorDo

	ALL       field.Asterisk
	ID        field.Int64
	CreatedAt field.Time
	UpdatedAt field.Time
	DeletedAt field.Field
	UserID    field.Int64
	UserName  field.String
	Level     field.Int64

	fieldMap map[string]field.Expr
}

func (a administrator) Table(newTableName string) *administrator {
	a.administratorDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a administrator) As(alias string) *administrator {
	a.administratorDo.DO = *(a.administratorDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *administrator) updateTableName(table string) *administrator {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.CreatedAt = field.NewTime(table, "created_at")
	a.UpdatedAt = field.NewTime(table, "updated_at")
	a.DeletedAt = field.NewField(table, "deleted_at")
	a.UserID = field.NewInt64(table, "user_id")
	a.UserName = field.NewString(table, "user_name")
	a.Level = field.NewInt64(table, "level")

	a.fillFieldMap()

	return a
}

func (a *administrator) WithContext(ctx context.Context) IAdministratorDo {
	return a.administratorDo.WithContext(ctx)
}

func (a administrator) TableName() string { return a.administratorDo.TableName() }

func (a administrator) Alias() string { return a.administratorDo.Alias() }

func (a administrator) Columns(cols ...field.Expr) gen.Columns {
	return a.administratorDo.Columns(cols...)
}

func (a *administrator) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *administrator) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 7)
	a.fieldMap["id"] = a.ID
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["deleted_at"] = a.DeletedAt
	a.fieldMap["user_id"] = a.UserID
	a.fieldMap["user_name"] = a.UserName
	a.fieldMap["level"] = a.Level
}

func (a administrator) clone(db *gorm.DB) administrator {
	a.administratorDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a administrator) replaceDB(db *gorm.DB) administrator {
	a.administratorDo.ReplaceDB(db)
	return a
}

type administratorDo struct {
	gen.GenericsDo[IAdministratorDo, *model.Administrator]
}
type IAdministratorDo interface {
	gen.IGenericsDo[IAdministratorDo, *model.Administrator]
}

func (a *administratorDo) withDO(do gen.Dao) IAdministratorDo {
	_r := &administratorDo{}
	_r.DO = *do.(*gen.DO)
	_r.IWithDO = gen.WithDOFunc[IAdministratorDo](a.withDO)
	return _r
}
